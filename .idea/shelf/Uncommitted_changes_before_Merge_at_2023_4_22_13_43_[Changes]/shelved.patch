Index: pkg/kubelet/kubelet.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/kubelet/kubelet.go b/pkg/kubelet/kubelet.go
new file mode 100644
--- /dev/null	(date 1682142202385)
+++ b/pkg/kubelet/kubelet.go	(date 1682142202385)
@@ -0,0 +1,14 @@
+package kubelet
+
+type Kubelet struct {
+}
+
+// Run kubelet运行的入口函数
+func (kl *Kubelet) Run() {
+
+}
+
+// NewKubelet kubelet对象的构造函数
+func NewKubelet() (*Kubelet, error) {
+
+}
Index: cmd/main.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/main.go b/cmd/kubelet/main.go
rename from cmd/main.go
rename to cmd/kubelet/main.go
--- a/cmd/main.go	(revision 2df35ca18fec7a389c8a3dac949ab54d26012caf)
+++ b/cmd/kubelet/main.go	(date 1682142202385)
@@ -3,7 +3,7 @@
 import (
 	"fmt"
 	"gopkg.in/yaml.v3"
-	"k8s/pkg/api/pod"
+	pod2 "k8s/pkg/api/pod"
 	"log"
 	"os"
 	"time"
@@ -22,12 +22,12 @@
 
 func main() {
 	// 解析pod的yaml配置文件
-	dataBytes, err := os.ReadFile("pkg/api/pod/podConfigTest.yaml")
+	dataBytes, err := os.ReadFile("pkg/api/kubelet/pod/podConfigTest.yaml")
 	if err != nil {
 		fmt.Println("读取文件失败：", err)
 		return
 	}
-	var podData pod.Pod
+	var podData pod2.Pod
 	err2 := yaml.Unmarshal(dataBytes, &podData)
 	if err2 != nil {
 		fmt.Println("解析 yaml 文件失败：", err)
@@ -35,7 +35,7 @@
 	fmt.Println(podData)
 
 	// 根据配置文件创建容器
-	err = pod.CreatePod(podData)
+	err = pod2.CreatePod(podData)
 	if err != nil {
 		fmt.Println(err.Error())
 	}
Index: pkg/api/pod/container.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package pod\r\n\r\nimport \"C\"\r\nimport (\r\n\t\"context\"\r\n\t\"fmt\"\r\n\t\"github.com/docker/docker/api/types\"\r\n\t\"github.com/docker/docker/api/types/container\"\r\n\t\"github.com/docker/docker/api/types/filters\"\r\n\t\"github.com/docker/docker/api/types/mount\"\r\n\tvolume2 \"github.com/docker/docker/api/types/volume\"\r\n\t\"github.com/docker/docker/client\"\r\n\t\"github.com/docker/go-connections/nat\"\r\n\t\"io\"\r\n\t\"log\"\r\n\t\"strconv\"\r\n)\r\n\r\nvar Client = newClient()\r\nvar Ctx = context.Background()\r\n\r\nfunc newClient() *client.Client {\r\n\tcli, err := client.NewClientWithOpts(client.WithVersion(\"1.41\"))\r\n\tdefer cli.Close()\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn cli\r\n}\r\n\r\n/*-----------------------Image------------------------*/\r\n\r\n// PullImages 拉取本地没有的镜像们，以及pause要用到的镜像\r\nfunc PullImages(images []string) error {\r\n\timages = append(images, \"registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6\")\r\n\tfor _, image := range images {\r\n\t\texisted, err := isImageExist(image)\r\n\t\tif err != nil {\r\n\t\t\treturn err\r\n\t\t}\r\n\t\tif !existed {\r\n\t\t\terr1 := pullSingleImage(image)\r\n\t\t\tlog.Printf(\"Succeesfully pull image %s\\n\", image)\r\n\t\t\tif err1 != nil {\r\n\t\t\t\treturn err1\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlog.Printf(\"Image %s is already existed\\n\", image)\r\n\t\t}\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// ListImage 列出镜像\r\nfunc ListImage() error {\r\n\timages, err := Client.ImageList(Ctx, types.ImageListOptions{})\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t\treturn err\r\n\t}\r\n\tfor _, image := range images {\r\n\t\tfmt.Println(image.RepoTags)\r\n\t}\r\n\treturn nil\r\n}\r\n\r\n// 查看本地是否有该镜像\r\nfunc isImageExist(name string) (bool, error) {\r\n\tcurList, err := Client.ImageList(Ctx, types.ImageListOptions{})\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t\treturn false, err\r\n\t}\r\n\tfor _, image := range curList {\r\n\t\tfor _, curName := range image.RepoTags {\r\n\t\t\tif curName == name {\r\n\t\t\t\treturn true, nil\r\n\t\t\t}\r\n\t\t\ttmp := name + \":latest\"\r\n\t\t\tif tmp == curName {\r\n\t\t\t\treturn true, nil\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn false, nil\r\n}\r\n\r\n// 通过网络拉取单个镜像\r\nfunc pullSingleImage(image string) error {\r\n\tlog.Printf(\"Prepare to pull image:%s\\n\", image)\r\n\tout, err := Client.ImagePull(context.Background(), image, types.ImagePullOptions{})\r\n\tif err != nil {\r\n\t\tfmt.Printf(\"PullSingleImage: Fail to pull image, err:%v\\n\", err)\r\n\t\treturn err\r\n\t}\r\n\tdefer out.Close()\r\n\tio.Copy(log.Writer(), out)\r\n\treturn nil\r\n}\r\n\r\n/*-----------------------Volume------------------------*/\r\n\r\n// 创建数据卷们\r\nfunc createVolumes(volumesConfig []VolumeConfig) ([]volume2.Volume, error) {\r\n\tvar result []volume2.Volume\r\n\tfor _, config := range volumesConfig {\r\n\t\texisted, err := isVolumeExisted(config.Name)\r\n\t\tif err != nil {\r\n\t\t\tfmt.Println(err)\r\n\t\t\treturn result, err\r\n\t\t}\r\n\r\n\t\tif existed {\r\n\t\t\tlog.Printf(\"Volume %s already existed, no need to create\\n\", config.Name)\r\n\t\t\tcontinue\r\n\t\t} else {\r\n\t\t\tnewVolume, err1 := Client.VolumeCreate(Ctx, volume2.CreateOptions{\r\n\t\t\t\tName: config.Name,\r\n\t\t\t})\r\n\t\t\tif err1 != nil {\r\n\t\t\t\tfmt.Println(err1)\r\n\t\t\t\treturn result, err1\r\n\t\t\t}\r\n\t\t\tlog.Printf(\"Successfully create Volume %s\\n\", config.Name)\r\n\t\t\tresult = append(result, newVolume)\r\n\t\t}\r\n\t}\r\n\r\n\treturn result, nil\r\n}\r\n\r\n// 获取已创建的数据卷\r\nfunc lisVolumes() ([]*volume2.Volume, error) {\r\n\tvar ret []*volume2.Volume\r\n\tvolumes, err := Client.VolumeList(context.Background(), filters.NewArgs())\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t\treturn nil, err\r\n\t}\r\n\r\n\tfor _, vol := range volumes.Volumes {\r\n\t\tret = append(ret, vol)\r\n\t}\r\n\treturn ret, nil\r\n}\r\n\r\n// 查看是否已有该卷\r\nfunc isVolumeExisted(name string) (bool, error) {\r\n\tvolumes, err := Client.VolumeList(context.Background(), filters.NewArgs())\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t\treturn false, err\r\n\t}\r\n\tfor _, vol := range volumes.Volumes {\r\n\t\tif vol.Name == name {\r\n\t\t\treturn true, nil\r\n\t\t}\r\n\t}\r\n\treturn false, nil\r\n}\r\n\r\n/*----------------------Container------------------------*/\r\n\r\n// CreateContainers 创建容器们\r\nfunc CreateContainers(containerConfigs []Container) ([]ContainerMeta, error) {\r\n\tvar result []ContainerMeta\r\n\tvar totalPort []int\r\n\tdupMap := make(map[int32]bool)\r\n\r\n\t//port, 各个容器共享同一个network命名空间即可通过localhost进行相互访问\r\n\t//用container网络模式跟pause容器（pause自己用的是默认的bridge模式）共享\r\n\tfor _, config := range containerConfigs {\r\n\t\tfor _, port := range config.Ports {\r\n\t\t\tif !dupMap[port.Port] {\r\n\t\t\t\tdupMap[port.Port] = true\r\n\t\t\t\ttotalPort = append(totalPort, int(port.Port))\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//create pause container\r\n\tpauseID, err3 := createPause(&totalPort)\r\n\tif err3 != nil {\r\n\t\tfmt.Println(err3.Error())\r\n\t\treturn nil, err3\r\n\t}\r\n\tlog.Println(\"Create pause container\")\r\n\tresult = append(result, ContainerMeta{Name: \"pause\", ContainerID: pauseID})\r\n\r\n\tfor _, config := range containerConfigs {\r\n\t\t// volume mount\r\n\t\tvar mounts []mount.Mount\r\n\t\tmountType := mount.TypeBind\r\n\t\tif config.VolumeMounts != nil {\r\n\t\t\tfor _, it := range config.VolumeMounts {\r\n\t\t\t\texisted, err1 := isVolumeExisted(it.Name)\r\n\t\t\t\tif err1 != nil {\r\n\t\t\t\t\tfmt.Println(err1)\r\n\t\t\t\t\treturn nil, err1\r\n\t\t\t\t}\r\n\t\t\t\tif existed {\r\n\t\t\t\t\t// 若使用的是定义在pod中的emptyDir，则是挂载volume，否则就是挂载至宿主机指定目录\r\n\t\t\t\t\tmountType = mount.TypeVolume\r\n\t\t\t\t}\r\n\t\t\t\tmounts = append(mounts, mount.Mount{\r\n\t\t\t\t\tType:     mountType,\r\n\t\t\t\t\tSource:   it.Name,\r\n\t\t\t\t\tTarget:   it.MountPath,\r\n\t\t\t\t\tReadOnly: it.ReadOnly,\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tlog.Println(\"Add volume mounting config\")\r\n\r\n\t\t// resource\r\n\t\tresourceConfig := container.Resources{}\r\n\t\tif config.Resources.Limits.Cpu != \"\" {\r\n\t\t\tresourceConfig.NanoCPUs = parseCPU(config.Resources.Limits.Cpu)\r\n\t\t}\r\n\t\tif config.Resources.Limits.Memory != \"\" {\r\n\t\t\tresourceConfig.Memory = parseMemory(config.Resources.Limits.Memory)\r\n\t\t}\r\n\t\tlog.Println(\"Add resource config\")\r\n\r\n\t\t// create container (可使用localhost通信)\r\n\t\t// k8s中pod内容器共享了net、ipc、uts namespace\r\n\t\tresp, err := Client.ContainerCreate(context.Background(), &container.Config{\r\n\t\t\tImage:      config.Image,\r\n\t\t\tEntrypoint: config.Command,\r\n\t\t\tCmd:        config.Args,\r\n\t\t}, &container.HostConfig{\r\n\t\t\tNetworkMode: container.NetworkMode(\"container:\" + pauseID),\r\n\t\t\tMounts:      mounts,\r\n\t\t\tIpcMode:     container.IpcMode(\"container:\" + pauseID),\r\n\t\t\tUTSMode:     container.UTSMode(\"container\" + pauseID),\r\n\t\t\tResources:   resourceConfig,\r\n\t\t}, nil, nil, config.Name)\r\n\t\tif err != nil {\r\n\t\t\treturn nil, err\r\n\t\t}\r\n\t\tlog.Printf(\"Create container %s\\n\", resp.ID)\r\n\r\n\t\t// record container ID\r\n\t\tresult = append(result, ContainerMeta{\r\n\t\t\tName:        config.Name,\r\n\t\t\tContainerID: resp.ID,\r\n\t\t})\r\n\t}\r\n\treturn result, nil\r\n}\r\n\r\n// StartContainer 启动容器\r\nfunc StartContainer(containerID string) {\r\n\terr := Client.ContainerStart(Ctx, containerID, types.ContainerStartOptions{})\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t} else {\r\n\t\tlog.Println(\"Container \", containerID, \"starts successfully\")\r\n\t}\r\n}\r\n\r\n// StopContainer 停止容器\r\nfunc StopContainer(containerID string) {\r\n\ttimeout := 10\r\n\terr := Client.ContainerStop(Ctx, containerID, container.StopOptions{\r\n\t\tTimeout: &timeout,\r\n\t})\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t} else {\r\n\t\tlog.Printf(\"Container %s is stopped\\n\", containerID)\r\n\t}\r\n}\r\n\r\n// RemoveContainer 删除容器\r\nfunc RemoveContainer(containerID string) {\r\n\terr := Client.ContainerRemove(Ctx, containerID, types.ContainerRemoveOptions{})\r\n\tif err != nil {\r\n\t\tfmt.Println(err.Error())\r\n\t} else {\r\n\t\tlog.Printf(\"Container %s is removed\\n\", containerID)\r\n\t}\r\n}\r\n\r\n// 创建pause容器用于管理网络\r\nfunc createPause(ports *[]int) (string, error) {\r\n\tvar exports nat.PortSet\r\n\texports = make(nat.PortSet, len(*ports))\r\n\tfor _, port := range *ports {\r\n\t\t// 默认使用TCP协议\r\n\t\tp, err := nat.NewPort(\"tcp\", strconv.Itoa(port))\r\n\t\tif err != nil {\r\n\t\t\treturn \"\", err\r\n\t\t}\r\n\t\texports[p] = struct{}{}\r\n\t}\r\n\r\n\tresp, err := Client.ContainerCreate(context.Background(), &container.Config{\r\n\t\tImage:        \"registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6\",\r\n\t\tExposedPorts: exports,\r\n\t}, &container.HostConfig{\r\n\t\tIpcMode: container.IpcMode(\"shareable\"),\r\n\t\tUTSMode: container.UTSMode(\"shareable\"),\r\n\t}, nil, nil, \"pause\")\r\n\treturn resp.ID, err\r\n}\r\n\r\n/*-----------------------Tools------------------------*/\r\nfunc parseCPU(cpu string) int64 {\r\n\tlength := len(cpu)\r\n\tresult := 0.0\r\n\tif cpu[length-1] == 'm' {\r\n\t\tresult, _ = strconv.ParseFloat(cpu[:length-1], 32)\r\n\t\tresult *= 1e3\r\n\t} else {\r\n\t\tresult, _ = strconv.ParseFloat(cpu[:length], 32)\r\n\t}\r\n\treturn int64(result)\r\n}\r\n\r\nfunc parseMemory(mem string) int64 {\r\n\tlength := len(mem)\r\n\tresult, _ := strconv.Atoi(mem[:length-1])\r\n\tmark := mem[length-1]\r\n\tif mark == 'K' || mark == 'k' {\r\n\t\tresult *= 1024\r\n\t} else if mark == 'M' || mark == 'm' {\r\n\t\tresult *= 1024 * 1024\r\n\t} else if mark == 'G' || mark == 'g' {\r\n\t\tresult *= 1024 * 1024 * 1024\r\n\t}\r\n\treturn int64(result)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/api/pod/container.go b/pkg/api/pod/container.go
--- a/pkg/api/pod/container.go	(revision 2df35ca18fec7a389c8a3dac949ab54d26012caf)
+++ b/pkg/api/pod/container.go	(date 1682142202385)
@@ -233,6 +233,7 @@
 			Mounts:      mounts,
 			IpcMode:     container.IpcMode("container:" + pauseID),
 			UTSMode:     container.UTSMode("container" + pauseID),
+			PidMode:     container.PidMode("container" + pauseID),
 			Resources:   resourceConfig,
 		}, nil, nil, config.Name)
 		if err != nil {
